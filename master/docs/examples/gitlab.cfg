# -*- python -*-
# ex: set filetype=python:

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory.
#
# Are all your projects built the same way?
# Do you yearn for a way to do simple static configuration?
# If so, try writing a function!
#
# Here's an example that
# - uses a function to make adding new projects easy
# - provides a regular builder and a smoke test builder per project
# - stores secrets in separate files
# - integrates with GitLab, and does smoke builds on merge requests
# - demonstrates access control using GitLab authentication
#
# To use this example with your own local instance of GitLab:
#
# 0. Set up local mirrors of the gnu hello and time projects, e.g.
#  for proj in hello time
#  do
#    git clone --mirror git@gitlab.com:GNU/$proj.git
#    cd $proj
#    git push --mirror git@gitlab.example.com:build/gnu-$proj.git
#    cd ..
#  done
#
# 1. Edit this file to replace example.com with your own domain,
#  and adjust worker name and password in c['workers'].
#
# 2. Create secrets.dir next to master.cfg:
#  mkdir secrets.dir
#
# 3. Tell GitLab to use webhooks to request builds.
#  Pick a random password for our webhook and save it as a secret, e.g.
#    echo "<string-webhook-token>" > secrets.dir/my-webhook-token
#    chmod 600 secrets.dir/*
#  (where <value> is just a placeholder for a value).
#  For each project to build, create a webhook in the GitLab UI at
#    project / Settings / Integrations / Add Webhook
#  with a URL of e.g.
#    http://buildbot.example.com:8010/change_hook/gitlab
#  the secret chosen above,
#  and with push and merge request triggers checked.
#
#  Then start the build master and worker.
#  Test the webhook by visiting
#    project / Settings / Integrations / Webhooks
#  and clicking 'test' on your webhook.
#  If something goes wrong, GitLab will show a red banner with the reason.
#  GitLab merge requests should now trigger buildbot builds.
#
# 4. Tell buildbot to report build status to GitLab.
#  Uncomment sections below marked
#    "CONFIGME: uncomment for gitlab status reporting"
#  Create a GitLab access token (so buildbot can send status to GitLab).
#  Pick a display name for your buildbot and save it as a secret, e.g.
#    echo "<string-buildbot-name>" > secrets.dir/my-buildbot-name
#    chmod 600 secrets.dir/*
#  Create an access token in the GitLab UI at
#    "User Settings / Access Tokens / Add a personal access token"
#  using that display name as the context, and save it as a secret, e.g.
#    echo "<string-gitlab-token>" > secrets.dir/my-gitlab-token
#    chmod 600 secrets.dir/*
#
#  Then restart the master.
#  GitLab merge requests should now show status of buildbot's builds.
#
# 5. Tell GitLab to accept authentication requests from buildbot.
#  Enter the URL of your buildbot gitlab hook, e.g.
#    http://buildbot.example.com:8010/change_hook/gitlab
#  into the GitLab UI at
#    "User Settings / Applications / Add New Application",
#  with scopes 'api' and 'openid' ticked,
#  and save the appid and secret it produces:
#    echo "<longhexstring-appid>" > secrets.dir/my-gitlab-appid
#    echo "<longhexstring-appsecret>" > secrets.dir/my-gitlab-appsecret
#    chmod 600 secrets.dir/*
# 6. Restrict buildbot web UI access to logged in GitLab users.
#  Uncomment sections below marked
#    "CONFIGME: uncomment for buildbot authentication"
#  and replace <mygroup> with a valid GitLab group.
#
#  Then restart the master.
#  Buildbot's web ui should now require you to be logged in to
#  that GitLab group before it shows you much or lets you force builds.

from buildbot.plugins import *
import os
import re

def addGitLabProject(repourl, workernames, branch=None):
    '''
    Add a builder and a merge request builder for the given branch
    of the given project, running on the given workers.
    Give each a Force button.
    Gets project name from the repourl, ignoring namespace.
    '''

    if branch is None:
        branch = "master"
    # Strip off everything before project name
    # FIXME: parse this more artfully to allow projects in folders
    name = re.sub(r'^.*/', '', repourl)
    # Strip off .git suffix, if present
    name = re.sub(r'\.git$', '', name)

    # Regular builder
    # Adjust this factory to match your site's build steps.
    # This example uses the canonical gnu configure/make steps.
    factory = util.BuildFactory()
    factory.addStep(steps.GitLab(repourl=repourl, mode='incremental'))
    factory.addStep(steps.ShellCommand(haltOnFailure=True, command=["sh", "-c", "if test -x ./bootstrap; then ./bootstrap; fi"]))
    factory.addStep(steps.ShellCommand(haltOnFailure=True, command=["./configure"]))
    factory.addStep(steps.ShellCommand(haltOnFailure=True, command=["make"]))
    factory.addStep(steps.ShellCommand(haltOnFailure=True, command=["make", "check"]))
    factory.addStep(steps.ShellCommand(haltOnFailure=True, command=["echo", "would package and upload here if this were a real project"]))

    id = name + "-" + branch
    c['schedulers'].append(schedulers.SingleBranchScheduler(
        name=id,
        change_filter=util.ChangeFilter(
            project=name, branch=branch, category="push"),
        treeStableTimer=None,
        builderNames=[id]))
    c['schedulers'].append(schedulers.ForceScheduler(
        name=id + '-force',
        builderNames=[id]))
    c['builders'].append(
        util.BuilderConfig(name=id,
                           workernames=workernames,
                           factory=factory))

    # Merge request builder (e.g. smoke test, don't fully publish artifacts;
    # for quick feedback of works-in-progress)
    # Adjust this factory to match your site's build steps.
    tryfactory = util.BuildFactory()
    tryfactory.addStep(steps.GitLab(repourl=repourl, mode='incremental'))
    tryfactory.addStep(steps.ShellCommand(haltOnFailure=True, command=["sh", "-c", "if test -x ./bootstrap; then ./bootstrap; fi"]))
    tryfactory.addStep(steps.ShellCommand(haltOnFailure=True, command=["./configure"]))
    tryfactory.addStep(steps.ShellCommand(haltOnFailure=True, command=["make"]))
    tryfactory.addStep(steps.ShellCommand(haltOnFailure=True, command=["make", "check"]))
    tryid = name + "-" + branch + "-try"
    c['schedulers'].append(schedulers.SingleBranchScheduler(
        name=tryid,
        change_filter=util.ChangeFilter(
            project=name, branch=branch, category="merge_request"),
        treeStableTimer=None,
        builderNames=[tryid]))
    c['schedulers'].append(schedulers.ForceScheduler(
        name=tryid + '-force',
        builderNames=[tryid]))
    c['builders'].append(
        util.BuilderConfig(name=tryid,
                           workernames=workernames,
                           factory=tryfactory))


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### SECRETS
# Checking secrets into your master.cfg is insecure;
# best practice is to keep them elsewhere else.

# Place the secrets directory next to master.cfg:
secrets_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'secrets.dir')
c['secretsProviders'] = [secrets.SecretInAFile(dirname=secrets_dir)]

# For parts of buildbot that don't support Secret interpolation yet
# Once https://github.com/buildbot/buildbot/issues/4118 is fixed,
# use util.Secret(s) instead.
def dumbSecret(s):
    with open(os.path.join(secrets_dir, s), 'r') as myfile:
        return myfile.read().replace('\n', '')

####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
# CONFIGME
c['workers'] = [worker.Worker("buildbot-worker", "buildbot-pass")]
workernames = ["buildbot-worker"]

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that workers
# could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': 9989}}

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

c['change_source'] = []

####### SCHEDULERS AND BUILDERS

# The Schedulers decide how to react to incoming changes.
c['schedulers'] = []
# The 'builders' list defines the Builders, which tell Buildbot how to
# perform a build: what steps, and which workers can execute them.
# Note that any particular build will only take place on one worker.
c['builders'] = []

# Call addGitLabProject once for each similar project you want to build.
# It adds factories, schedulers, and builders for the project
# in one fell swoop, making it easier to have a large number
# of similar projects.
addGitLabProject('git@gitlab.example.com:build/gnu-hello', workernames)
addGitLabProject('git@gitlab.example.com:build/gnu-time', workernames)

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

c['services'] = []

# CONFIGME: uncomment for gitlab status reporting
## Report build status back to GitLab UI
#c['services'].append(reporters.GitLabStatusPush(
#    token=util.Secret('my-gitlab-token'),
#    context=util.Secret('my-buildbot-name'),
#    baseURL='https://gitlab.example.com',
#    verbose=True))

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = "Gnu Hello GitLab"
c['titleURL'] = "https://gitlab.example.com/build/"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = "http://buildbot.example.com:8010/"

# CONFIGME: uncomment for buildbot authentication
## This example tries to show nothing to anonymous users.
#authz = util.Authz(
#  allowRules=[
#    # CONFIGME: replace "<mygroup>" here with a valid gitlab group
#    util.AnyEndpointMatcher(role="<mygroup>"),
#    util.AnyEndpointMatcher(role="snorglepuss-does-not-exist", defaultDeny=True),
#  ],
#  roleMatchers=[
#    util.RolesFromGroups()
#  ]
#)

# minimalistic config to activate new web UI
c['www'] = dict(
    port=8010,
    # CONFIGME: uncomment for buildbot authentication
    #auth=util.GitLabAuth("https://gitlab.example.com",
    #                     dumbSecret('my-gitlab-appid'),
    #                     dumbSecret('my-gitlab-appsecret')),
    #authz=authz,
    change_hook_dialects=dict(
       gitlab={
           'secret': dumbSecret('my-webhook-token')
       },
    ),
    plugins=dict(waterfall_view={}, console_view={}, grid_view={}))


# Let buildbot developers know you're using gitlab support :-)
c['buildbotNetUsageData'] = 'basic'

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
