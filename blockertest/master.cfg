# -*- python -*-
# ex: set syntax=python:

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory (although the filename
# can be changed with the --basedir option to 'mktap buildbot master').

# It has one job: define a dictionary named BuildmasterConfig. This
# dictionary has a variety of keys to control different aspects of the
# buildmaster. They are documented in docs/config.xhtml .


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# the 'slaves' list defines the set of allowable buildslaves. Each element is
# a tuple of bot-name and bot-password. These correspond to values given to
# the buildslave's mktap invocation.
from buildbot.buildslave import BuildSlave
c['slaves'] = [BuildSlave("slaveA", "slaveA"),
               BuildSlave("slaveB", "slaveB"),
              ]

# 'slavePortnum' defines the TCP port to listen on. This must match the value
# configured into the buildslaves (with their --master option)

c['slavePortnum'] = 9989


####### SCHEDULERS

#from buildbot.scheduler import Scheduler
c['schedulers'] = []
#c['schedulers'].append(Scheduler(name="all", branch=None,
#                                 treeStableTimer=2*60,
#                                 builderNames=["buildbot-full"]))

####### BUILDERS

# the 'builders' list defines the Builders. Each one is configured with a
# dictionary, using the following keys:
#  name (required): the name used to describe this bilder
#  slavename (required): which slave to use, must appear in c['bots']
#  builddir (required): which subdirectory to run the builder in
#  factory (required): a BuildFactory to define how the build is run
#  periodicBuildTime (optional): if set, force a build every N seconds

from buildbot.process import factory
from buildbot.steps.shell import ShellCommand
from buildbot.steps.blocker import Blocker

c['builders'] = []

def addBuilderPair(idx, factoryA, factoryB):
    name = "builder%dA" % idx
    builderA = {'name':      name,
                'slavename': "slaveA",
                'builddir':  name,
                'factory':   factoryA}
    name = "builder%dB" % idx
    builderB = {'name':      name,
                'slavename': "slaveB",
                'builddir':  name,
                'factory':   factoryB}
    c['builders'] += [builderA, builderB]

class MyFactory(factory.BuildFactory):
    """
    Override addStep() so every build step has a sensible description:
    it's the same as the name.
    """
    def addStep(self, step):
        if hasattr(step, 'description') and step.description is None:
            step.factory[1]['description'] = step.name
        factory.BuildFactory.addStep(self, step)


# TEST 1: dead simple.  

factory1A = MyFactory()
factory1A.addStep(
    ShellCommand(name="sleep",
                 command=["sleep", "3"]))

factory1B = MyFactory()
factory1B.addStep(Blocker(name="blockB",
                          upstreamSteps=[("builder1A", "sleep")]))

addBuilderPair(1, factory1A, factory1B)


# TEST 2: same, with more steps

factory2A = MyFactory()
factory2A.addStep(ShellCommand(name="ls", command=["ls", "-lt"]))
factory2A.addStep(ShellCommand(name="sleep", command=["sleep", "3"]))
factory2A.addStep(ShellCommand(name="date", command=["date"]))

factory2B = MyFactory()
factory2B.addStep(ShellCommand(name="foo", command=["echo", "foo"]))
factory2B.addStep(Blocker(name="blockB",
                          upstreamSteps=[("builder2A", "date")]))
factory2B.addStep(ShellCommand(name="date", command=["date"]))

addBuilderPair(2, factory2A, factory2B)


# TEST 3: ping-pong blockers

factory3A = MyFactory()
factory3B = MyFactory()

factory3A.addStep(ShellCommand(name="setupA", command=["sleep", "3"]))

factory3B.addStep(Blocker(name="blockB",
                          upstreamSteps=[("builder3A", "setupA")]))

# These two steps run concurrently because 'blockB' blocks 'buildB' from running
# until 'setupA' is done.
factory3A.addStep(ShellCommand(name="buildA", command=["sleep", "2"]))
factory3B.addStep(ShellCommand(name="buildB", command=["sleep", "5"]))

# Finally, the 'finishA' step is blocked from running until 'buildB' is done.
# (Step 'finishB' is just there so we can compare timestamps again.)
factory3A.addStep(Blocker(name="blockA",
                          upstreamSteps=[("builder3B", "buildB")]))
factory3A.addStep(ShellCommand(name="finishA", command=["date"]))
factory3B.addStep(ShellCommand(name="finishB", command=["date"]))

addBuilderPair(3, factory3A, factory3B)

# TEST 4: Blocker that doesn't block

factory4A = MyFactory()
factory4B = MyFactory()

factory4A.addStep(ShellCommand(name="buildA", command=["sleep", "2"]))
factory4B.addStep(ShellCommand(name="buildB", command=["sleep", "5"]))
factory4B.addStep(Blocker(name="blockB", upstreamSteps=[("builder4A", "buildA")]))
factory4A.addStep(ShellCommand(name="finishA", command=["date"]))
factory4B.addStep(ShellCommand(name="finishB", command=["date"]))

addBuilderPair(4, factory4A, factory4B)


# TEST 5: config error (bad builder)

factory5A = MyFactory()
factory5B = MyFactory()

factory5B.addStep(Blocker(name="blockB", upstreamSteps=[("foo", "build")]))

addBuilderPair(5, factory5A, factory5B)


# TEST 6: config error (bad build step)

factory6A = MyFactory()
factory6B = MyFactory()

factory6B.addStep(Blocker(name="blockB", upstreamSteps=[("builder6A", "foo")]))

addBuilderPair(6, factory6A, factory6B)


# TEST 7: upstream failure

factory7A = MyFactory()
factory7B = MyFactory()

factory7A.addStep(ShellCommand(name="crash", command="sleep 1 && false"))
factory7B.addStep(Blocker(name="blockB", upstreamSteps=[("builder7A", "crash")]))

addBuilderPair(7, factory7A, factory7B)


# TEST 8: multiple upstream steps

factory8A = MyFactory()
factory8B = MyFactory()

factory8A.addStep(ShellCommand(name="prep", command=["true"]))
factory8A.addStep(ShellCommand(name="buildA", command=["sleep", "2"]))
factory8B.addStep(ShellCommand(name="buildB", command=["sleep", "1"]))
factory8B.addStep(Blocker(name="blockB",
                          upstreamSteps=[("builder8A", "prep"),
                                         ("builder8A", "buildA"),
                                         ("builder8B", "buildB")]))

addBuilderPair(8, factory8A, factory8B)


# TEST 9: multiple upstream steps with failure

factory9A = MyFactory()
factory9B = MyFactory()

factory9A.addStep(ShellCommand(name="prep", command=["false"]))
factory9A.addStep(ShellCommand(name="buildA", command=["sleep", "2"]))
factory9B.addStep(ShellCommand(name="buildB", command=["sleep", "1"]))
factory9B.addStep(Blocker(name="blockB",
                          upstreamSteps=[("builder9A", "prep"),
                                         ("builder9A", "buildA"),
                                         ("builder9B", "buildB")]))

addBuilderPair(9, factory9A, factory9B)



####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
c['status'].append(html.WebStatus(http_port=9980, allowForce=True))

from buildbot.status import client
c['status'].append(client.PBListener(9988))


####### DEBUGGING OPTIONS

# if you set 'debugPassword', then you can connect to the buildmaster with
# the diagnostic tool in contrib/debugclient.py . From this tool, you can
# manually force builds and inject changes, which may be useful for testing
# your buildmaster without actually commiting changes to your repository (or
# before you have a functioning 'sources' set up). The debug tool uses the
# same port number as the slaves do: 'slavePortnum'.

c['debugPassword'] = "debug"

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
from buildbot import manhole
c['manhole'] = manhole.AuthorizedKeysManhole(9922, "authorized_keys")


####### PROJECT IDENTITY

c['projectName'] = "blockertest"
c['projectURL'] = ""

c['buildbotURL'] = "http://badger:9980/"

